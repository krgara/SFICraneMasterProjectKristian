<?xml version="1.0" encoding="UTF-8"?>
<project>
  <!--(*
 *
 * File: SFICraneModel_020523_WireLengthEstimatorExport.xml
 *
 * IEC 61131-3 Structured Text (ST) code generated for subsystem "SFICraneModel_020523_WireLengthEstimatorExport/WinchHeightControlFunction"
 *
 * Model name                      : SFICraneModel_020523_WireLengthEstimatorExport
 * Model version                   : 1.21
 * Model creator                   : krgar
 * Model last modified by          : krgar
 * Model last modified on          : Tue May 02 14:39:17 2023
 * Model sample time               : 0.002s
 * Subsystem name                  : SFICraneModel_020523_WireLengthEstimatorExport/WinchHeightControlFunction
 * Subsystem sample time           : 0.002s
 * Simulink PLC Coder version      : 3.7 (R2022b) 13-May-2022
 * ST code generated on            : Tue May 02 14:39:34 2023
 *
 * Target IDE selection            : PLCopen XML
 * Test Bench included             : No
 *
 *)
-->
  <fileHeader companyName="The Mathworks, Inc." companyURL="www.mathworks.com" contentDescription="" creationDateTime="2023-05-02T14:39:34" productName="Simulink PLC Coder" productRelease="(R2022b)" productVersion="3.7"/>
  <contentHeader name="SFICraneModel_020523_WireLengthEstimatorExport">
    <coordinateInfo>
      <fbd>
        <scaling x="0" y="0"/>
      </fbd>
      <ld>
        <scaling x="0" y="0"/>
      </ld>
      <sfc>
        <scaling x="0" y="0"/>
      </sfc>
    </coordinateInfo>
  </contentHeader>
  <types>
    <dataTypes/>
    <pous>
      <pou name="WinchHeightControlFunction" pouType="functionBlock">
        <interface>
          <inputVars>
            <variable name="fTheta1">
              <type>
                <LREAL/>
              </type>
            </variable>
            <variable name="fStrokeActuatorMain">
              <type>
                <LREAL/>
              </type>
            </variable>
            <variable name="fStrokeActuatorKnuckle">
              <type>
                <LREAL/>
              </type>
            </variable>
            <variable name="thetaWinchMotorIni">
              <type>
                <LREAL/>
              </type>
            </variable>
            <variable name="desiredHeightPayload">
              <type>
                <LREAL/>
              </type>
            </variable>
          </inputVars>
          <outputVars>
            <variable name="PTx">
              <type>
                <LREAL/>
              </type>
            </variable>
            <variable name="PTy">
              <type>
                <LREAL/>
              </type>
            </variable>
            <variable name="fTheta3">
              <type>
                <LREAL/>
              </type>
            </variable>
            <variable name="fTheta4">
              <type>
                <LREAL/>
              </type>
            </variable>
            <variable name="thetaWinchMotor">
              <type>
                <LREAL/>
              </type>
            </variable>
          </outputVars>
          <localVars>
            <variable name="PTy_tmp">
              <type>
                <LREAL/>
              </type>
            </variable>
            <variable name="PTy_tmp_0">
              <type>
                <LREAL/>
              </type>
            </variable>
          </localVars>
        </interface>
        <body>
          <ST>
            <xhtml xmlns="http://www.w3.org/1999/xhtml"><![CDATA[
(* MATLAB Function: '<Root>/WinchHeightControlFunction' *)
(* Platform constants *)
(* MATLAB Function 'WinchHeightControlFunction': '<S1>:1' *)
(* '<S1>:1:4' fHeightPlatform = 1.402; *)
(* '<S1>:1:5' fHeightPlatformKing = 0.09; *)
(* '<S1>:1:6' fLengthPlatform = 1.30; *)
(* Crane and platform dimensions *)
(* Crane constant parameters *)
(* '<S1>:1:11' fHeightKingSlew             = 0.623; *)
(* '<S1>:1:12' fHeightSlewTop              = 0.711; *)
(* '<S1>:1:13' fLengthMainArm			    = 1.5; *)
(* '<S1>:1:14' fLengthKnuckleArm		    = 1.158; *)
(* '<S1>:1:16' fLengthAMain				= 0.614; *)
(* '<S1>:1:17' fLengthBMain				= 0.571; *)
(* '<S1>:1:18' fMinLengthActuatorMain		= 0.692; *)
(* '<S1>:1:19' fMaxStrokeActuatorMain		= 0.320; *)
(* '<S1>:1:21' fOffsetAngleDegMainAct		= 62.1; *)
(* '<S1>:1:22' fOffsetAngleRadMainAct		= deg2rad(fOffsetAngleDegMainAct); *)
(* '<S1>:1:24' fLengthAKnuckle				= 0.767; *)
(* '<S1>:1:25' fLengthBKnuckle				= 0.184; *)
(* '<S1>:1:26' fMinLengthActuatorKnuckle	= 0.627; *)
(* '<S1>:1:27' fMaxStrokeActuatorKnuckle	= 0.260; *)
(* '<S1>:1:29' fOffsetAngleDegKnuckleAct	= 86.3; *)
(* '<S1>:1:30' fOffsetAngleRadKnuckleAct	= deg2rad(fOffsetAngleDegKnuckleAct); *)
(* '<S1>:1:32' lengthOrigoToWinch = 0.2199; *)
(* '<S1>:1:33' heightOrigoToWinch = 0.0895; *)
(* '<S1>:1:34' lengthOrigoToSheave1 = 0.2348; *)
(* '<S1>:1:35' heightOrigoToSheave1 = 0.060; *)
(* '<S1>:1:36' lengthOrigoToSheave2 = 1.520; *)
(* '<S1>:1:37' heigthOrigoToSheave2 = 0.095; *)
(* '<S1>:1:38' lengthMainArmToSheave3 = 0.2591; *)
(* '<S1>:1:39' lengthMainArmToSheave4 = 1.158; *)
(* '<S1>:1:40' offsetAngleSheave3deg = 49.7; *)
(* '<S1>:1:41' offsetAngleSheave3rad = deg2rad(offsetAngleSheave3deg); *)
(* '<S1>:1:42' offsetAngleSheave4deg = 90; *)
(* '<S1>:1:43' offsetAngleSheave4rad = deg2rad(offsetAngleSheave4deg); *)
(* '<S1>:1:45' lengthMainArm = 1.500; *)
(* '<S1>:1:46' pitchRadiusWinch = 0.0716; *)
(* '<S1>:1:47' pitchRadiusSheave = 0.034; *)
(* Calculating angles for main arm *)
(* '<S1>:1:50' fLengthActuatorMain = fStrokeActuatorMain + fMinLengthActuatorMain; *)
(* '<S1>:1:52' fAngleMainArmAct = acos((fLengthBMain^2 + fLengthAMain^2 - fLengthActuatorMain^2) / (2 * fLengthBMain * fLengthAMain)); *)
(* '<S1>:1:54' fTheta3 = fAngleMainArmAct - fOffsetAngleRadMainAct; *)
fTheta3 := ACOS((0.70303699999999991 - ((fStrokeActuatorMain + 0.692) * (fStrokeActuatorMain + 0.692))) / 0.70118799999999992) - 1.0838494654884787;
(* Calculating angles for knuckle arm *)
(* '<S1>:1:57' fLengthActuatorKnuckle = fStrokeActuatorKnuckle + fMinLengthActuatorKnuckle; *)
(* '<S1>:1:59' fAngleKnuckleArmAct = acos((fLengthBKnuckle^2 + fLengthAKnuckle^2 - fLengthActuatorKnuckle^2) / (2 * fLengthBKnuckle * fLengthAKnuckle)); *)
(* '<S1>:1:61' fTheta4 = fAngleKnuckleArmAct - fOffsetAngleRadKnuckleAct; *)
fTheta4 := ACOS((0.62214500000000006 - ((fStrokeActuatorKnuckle + 0.627) * (fStrokeActuatorKnuckle + 0.627))) / 0.282256) - 1.5062191444711064;
(* '<S1>:1:64' fHeightMain                 = fHeightPlatformKing + fHeightKingSlew + fHeightSlewTop; *)
(* '<S1>:1:66' PTx = fLengthPlatform*cos(fTheta1) + fHeightMain*cos(fTheta1 + pi/2) + fLengthMainArm*cos(fTheta1 + fTheta3) + fLengthKnuckleArm * cos (fTheta1 + fTheta3 + fTheta4 - pi/2); *)
(* '<S1>:1:67' PTy = fHeightPlatform + fLengthPlatform*sin(fTheta1) + fHeightMain * sin(fTheta1 + pi/2) + fLengthMainArm *sin(fTheta1 + fTheta3) + fLengthKnuckleArm*sin(fTheta1 + fTheta3 + fTheta4 - pi/2); *)
PTy_tmp := fTheta1 + fTheta3;
PTy_tmp_0 := (PTy_tmp + fTheta4) - 1.5707963267948966;
PTy := ((((1.3 * SIN(fTheta1)) + 1.402) + (SIN(fTheta1 + 1.5707963267948966) * 1.424)) + (SIN(PTy_tmp) * 1.5)) + (SIN(PTy_tmp_0) * 1.158);
(* Outport: '<Root>/PTx' incorporates:
 *  MATLAB Function: '<Root>/WinchHeightControlFunction' *)
(* '<S1>:1:70' Pwx = -lengthOrigoToWinch; *)
(* '<S1>:1:71' Pwy = -heightOrigoToWinch; *)
(* '<S1>:1:72' Ps1x = lengthOrigoToSheave1 * cos(fTheta3) - heightOrigoToSheave1 * sin(fTheta3); *)
(* '<S1>:1:73' Ps1y = lengthOrigoToSheave1 * sin(fTheta3) + heightOrigoToSheave1 * cos(fTheta3); *)
(* '<S1>:1:74' Ps2x = lengthOrigoToSheave2 * cos(fTheta3) - heigthOrigoToSheave2 * sin(fTheta3); *)
(* '<S1>:1:75' Ps2y = lengthOrigoToSheave2 * sin(fTheta3) + heigthOrigoToSheave2 * cos(fTheta3); *)
(* '<S1>:1:76' Ps3x = lengthMainArm * cos(fTheta3) + lengthMainArmToSheave3 * cos(fTheta3 + fTheta4 - offsetAngleSheave3rad); *)
(* '<S1>:1:77' Ps3y = lengthMainArm * sin(fTheta3) + lengthMainArmToSheave3 * sin(fTheta3 + fTheta4 - offsetAngleSheave3rad); *)
(* '<S1>:1:78' Ps4x = lengthMainArm * cos(fTheta3) + lengthMainArmToSheave4 * cos(fTheta3 + fTheta4 - offsetAngleSheave4rad); *)
(* '<S1>:1:79' Ps4y = lengthMainArm * sin(fTheta3) + lengthMainArmToSheave4 * sin(fTheta3 + fTheta4 - offsetAngleSheave4rad); *)
(* function distance = distanceTwoPoints(P1x, P1y, P2x, P2y) *)
(* distance = sqrt((P2x - P1x)^2 + (P2y - P1y)^2); *)
(* end *)
(* '<S1>:1:85' distanceWinchSheave1 =  sqrt((Ps1x - Pwx)^2 + (Ps1y - Pwy)^2); *)
(* distanceTwoPoints(Pwx, Pwy, Ps1x, Ps1y); *)
(* '<S1>:1:86' distanceSheave1Sheave2 = sqrt((Ps2x - Ps1x)^2 + (Ps2y - Ps1y)^2); *)
(* distanceTwoPoints(Ps2x, Ps2y, Ps1x, Ps1y); *)
(* '<S1>:1:87' distanceSheave2Sheave3 = sqrt((Ps3x - Ps2x)^2 + (Ps3y - Ps2y)^2); *)
(* distanceTwoPoints(Ps2x, Ps2y, Ps3x, Ps3y); *)
(* '<S1>:1:88' distanceSheave3Sheave4 = sqrt((Ps4x - Ps3x)^2 + (Ps4y - Ps3y)^2); *)
(* distanceTwoPoints(Ps4x, Ps4y, Ps3x, Ps3y); *)
(* function tangentLength = tangentLengthFunction(distance, radius1, radius2) *)
(* tangentLength = sqrt(distance^2 -(radius1 -radius2)^2); *)
(* end *)
(* '<S1>:1:94' tangentLengthWinchSheave1 = sqrt(distanceWinchSheave1^2 -(pitchRadiusWinch -pitchRadiusSheave)^2); *)
(* tangentLengthFunction(distanceWinchSheave1, pitchRadiusWinch, pitchRadiusSheave); *)
(* '<S1>:1:95' tangentLengthSheave1Sheave2 = sqrt(distanceSheave1Sheave2^2 -(pitchRadiusSheave -pitchRadiusSheave)^2); *)
(* tangentLengthFunction(distanceSheave1Sheave2, pitchRadiusSheave, pitchRadiusSheave); *)
(* '<S1>:1:96' tangentLengthSheave2Sheave3 = sqrt(distanceSheave2Sheave3^2 -(pitchRadiusSheave -pitchRadiusSheave)^2); *)
(* tangentLengthFunction(distanceSheave2Sheave3, pitchRadiusSheave, pitchRadiusSheave); *)
(* '<S1>:1:97' tangentLengthSheave3Sheave4 = sqrt(distanceSheave3Sheave4^2 -(pitchRadiusSheave -pitchRadiusSheave)^2); *)
(* tangentLengthFunction(distanceSheave3Sheave4, pitchRadiusSheave, pitchRadiusSheave); *)
(* '<S1>:1:99' offsetAngleDeg = 113.6 + 9.9; *)
(* '<S1>:1:100' offsetAngleRad = deg2rad(offsetAngleDeg); *)
(* '<S1>:1:102' wrapAngle = offsetAngleRad - fTheta3 - fTheta4; *)
(* '<S1>:1:103' wrapLength = wrapAngle * pitchRadiusSheave; *)
(* '<S1>:1:105' wireLengthOnCrane = tangentLengthWinchSheave1 + tangentLengthSheave1Sheave2 + tangentLengthSheave2Sheave3 + tangentLengthSheave3Sheave4 + wrapLength; *)
(* '<S1>:1:107' lengthWinchWireIni = 3; *)
(* '<S1>:1:108' pitchRadiusWinch = 0.0716; *)
(* '<S1>:1:109' pitchRadiusSheave = 0.034; *)
(* '<S1>:1:110' gearRatioWinch = 32; *)
(* '<S1>:1:112' lengthWinchWire = PTy - desiredHeightPayload; *)
(* '<S1>:1:113' thetaWinch = (lengthWinchWire - lengthWinchWireIni) / pitchRadiusWinch; *)
(* '<S1>:1:114' thetaWinchMotor = thetaWinch*gearRatioWinch + thetaWinchMotorIni; *)
(* function distance = distanceTwoPoints(P1x, P1y, P2x, P2y) *)
(* distance = sqrt((P2x - P1x)^2 + (P2y - P1y)^2); *)
(* end *)

(* function tangentLength = tangentLengthFunction(distance, radius1, radius2) *)
(* tangentLength = sqrt(distance^2 -(radius1 -radius2)^2); *)
(* end *)
PTx := (((COS(fTheta1 + 1.5707963267948966) * 1.424) + (1.3 * COS(fTheta1))) + (COS(PTy_tmp) * 1.5)) + (COS(PTy_tmp_0) * 1.158);
(* Outport: '<Root>/thetaWinchMotor' incorporates:
 *  MATLAB Function: '<Root>/WinchHeightControlFunction' *)
thetaWinchMotor := ((((PTy - desiredHeightPayload) - 3.0) / 0.0716) * 32.0) + thetaWinchMotorIni;

]]></xhtml>
          </ST>
        </body>
      </pou>
    </pous>
  </types>
  <instances>
    <configurations/>
  </instances>
</project>
